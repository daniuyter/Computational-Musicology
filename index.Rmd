---
title: "Computational Musicology Portfolio"
author: "Daniel Uyterlinde"
date: "22 February 2023"
output:
  flexdashboard::flex_dashboard:
    storyboard: true
---

```{r, setup}
library(tidyverse)
library(plotly)
library(spotifyr)
library(compmus)
```

### Welcome to my portfolio!

```{r}

Sys.setenv(SPOTIFY_CLIENT_ID = 'e0b7bfdbe23340798ed4a387e11d1c33')
Sys.setenv(SPOTIFY_CLIENT_SECRET = '5aebd15afa39467fbf6e14ec48ce8fb7')

access_token <- get_spotify_access_token()

playlist_id <- "5WLcRUbX0ODQih9Fg2X5zG?si=02389b5f148b44e1"
playlist_data <- get_playlist(playlist_id)

bigmusicmountain <- 
  get_playlist_audio_features("", playlist_id) %>% 
  mutate(track.artists = map_chr(track.artists, \(x) x[1, "name"]))

# plot the acousticness and energy of the songs in the playlist, with the color of the points representing the artist
a <- ggplot(bigmusicmountain, aes(x = acousticness, y = energy, size=instrumentalness, color=valence, text = track.name)) +
  geom_point(alpha = 0.8) +
  geom_smooth() +
  scale_x_sqrt() +
  labs(title = "Acousticness and Energy of Songs in the Big Music Mountain Playlist",
       x = "Acousticness",
       y = "Energy")
ggplotly(a)
```

------------------------------------------------------------------------

this is a description

### This is the second tab

```{r}

# calculating medians
playlist_medians <- bigmusicmountain %>% 
  summarise(across(c(danceability, energy, key, loudness, mode, speechiness, 
                     acousticness, instrumentalness, liveness, valence, tempo), median))

playlist_medians_table <- playlist_medians %>%
  pivot_longer(everything(), names_to = "variable", values_to = "median")
playlist_medians_table

# calculating means
playlist_means <- bigmusicmountain %>% 
  summarise(across(c(danceability, energy, key, loudness, mode, speechiness, 
                     acousticness, instrumentalness, liveness, valence, tempo), mean))

playlist_means_table <- playlist_means %>%
  pivot_longer(everything(), names_to = "variable", values_to = "mean")
playlist_means_table

```

### New tab

```{r}

# Calculate Euclidean distance for each song
bigmusicmountain_dist <- bigmusicmountain %>% 
  mutate(dist = sqrt((danceability - playlist_medians$danceability)^2 +
                       (energy - playlist_medians$energy)^2 +
                       (key - playlist_medians$key)^2 +
                       (loudness - playlist_medians$loudness)^2 +
                       (mode - playlist_medians$mode)^2 +
                       (speechiness - playlist_medians$speechiness)^2 +
                       (acousticness - playlist_medians$acousticness)^2 +
                       (instrumentalness - playlist_medians$instrumentalness)^2 +
                       (liveness - playlist_medians$liveness)^2 +
                       (valence - playlist_medians$valence)^2 +
                       (tempo - playlist_medians$tempo)^2))

# Sort by distance and select first row (i.e., song with smallest distance)
most_average_song <- bigmusicmountain_dist %>% 
  arrange(dist) %>% 
  slice(1)

most_average_song

least_average_song <- bigmusicmountain_dist %>% 
  arrange(-dist) %>% 
  slice(1)
least_average_song


```

### Violin

```{r}

# violin plot with valence
bigmusicmountain |>
  ggplot(aes(x = playlist_name, y=valence))+
    geom_violin()

```

### Test new idea

```{r}

# Extract the audio feature columns
audio_features_cols <- bigmusicmountain %>%
  select(danceability, energy, key, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo)

# Standardize the audio feature data
audio_features_scaled <- scale(audio_features_cols)

# Perform clustering with k=5 using k-means algorithm
set.seed(123)
k <- 5
km <- kmeans(audio_features_scaled, centers = k)

# Add cluster labels to the audio features data
audio_features_clustered <- bigmusicmountain %>%
  mutate(cluster = km$cluster)

# Print the number of songs in each cluster
table(audio_features_clustered$cluster)

# Create a scatterplot of the clustered data
p <- ggplot(audio_features_clustered, aes(x = danceability, y = energy, color = factor(cluster), text = str_c(track.artists))) +
  geom_point(alpha = 0.7) +
  xlab("Danceability") +
  ylab("Energy") +
  ggtitle("Audio Feature Clustering") +
  theme_bw()
ggplotly(p)
```

### kmeans clusters

```{r}
# print the songs in each cluster

```

### Chromagram

```{r}
castlesjimi <- get_tidy_audio_analysis("3qebSLgUwaEqbwCM5sj5Kh") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

castlesrhcp <- get_tidy_audio_analysis("7mUNyl16vX2OrKqMAuZJF9") %>%
  select(segments) %>%
  unnest(segments) %>%
  select(start, duration, pitches)

castles <- bind_rows(
  castlesjimi %>% mutate(song = "Jimi Hendrix"),
  castlesrhcp %>% mutate(song = "Red Hot Chili Peppers")
)

castles %>%
  mutate(pitches = map(pitches, compmus_normalise, "euclidean")) %>%
  compmus_gather_chroma() %>%
  ggplot(aes(
    x = start + duration / 2,
    width = duration * 2,
    y = pitch_class,
    fill = value
  )) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude", title = "Castles Made of Sand") +
  theme_minimal() +
  scale_fill_viridis_c() +
  facet_grid(rows = vars(song))
```

### Dynamic time warping

```{r}
compmus_long_distance(
  castlesjimi |> mutate(pitches = map(pitches, compmus_normalise, "chebyshev")),
  castlesrhcp |> mutate(pitches = map(pitches, compmus_normalise, "chebyshev")),
  feature = pitches,
  method = "euclidean"
) |>
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_equal() +
  labs(x = "Jimi Hendrix", y = "Red Hot Chili Peppers") +
  theme_minimal() +
  scale_fill_viridis_c(guide = NULL)
```

### Cepstogram

```{r}
 dernkala <-
  get_tidy_audio_analysis("6S1TC3ESLe7PbrztzsQmw4?si=bdddedf19a534d4c") |> # Change URI.
  compmus_align(bars, segments) |>                     # Change `bars`
  select(bars) |>                                      #   in all three
  unnest(bars) |>                                      #   of these lines.
  mutate(
    pitches =
      map(segments,
        compmus_summarise, pitches,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  ) |>
  mutate(
    timbre =
      map(segments,
        compmus_summarise, timbre,
        method = "rms", norm = "euclidean"              # Change summary & norm.
      )
  )
 
 dernkala |>
  compmus_gather_timbre() |>
  ggplot(
    aes(
      x = start + duration / 2,
      width = duration,
      y = basis,
      fill = value
    )
  ) +
  geom_tile() +
  labs(x = "Time (s)", y = NULL, fill = "Magnitude") +
  scale_fill_viridis_c() +                              
  theme_classic()
```

### Self similarity matrix

```{r}
dernkala |>
  compmus_self_similarity(timbre, "cosine") |> 
  ggplot(
    aes(
      x = xstart + xduration / 2,
      width = xduration,
      y = ystart + yduration / 2,
      height = yduration,
      fill = d
    )
  ) +
  geom_tile() +
  coord_fixed() +
  scale_fill_viridis_c(guide = "none") +
  theme_classic() +
  labs(x = "", y = "")

```
